include "io.brandejs"
include "str.brandejs"


; STD: assert(condition: bool, message: @char[]) -> void
; raises error if condition is false
def assert(condition: bool, message: @char[]) -> void {
    if (not condition) error(*message)
}

; STD: error(message: @char[]) -> void
; prints error message and jumps to error label
def error(message: @char[]) -> void {
    println(*"[Error occured]")
    println(*message)
    $ jmp error
}

; STD: exit() -> void
; jumps to exit label and ends the program
; TODO: add optional argument for exiting with error
def exit() -> void {
    $ jmp exit
}




HEAP: char[4096] = []
HEAP_TAKENh: int = 0
HEAP_TAKENl: int = 0
HEAP_LENGTHS: char[32] = []

; 32bit mask for 128byte blocks flags for occupation

; Malloc implementation
def malloc(size: int) -> char[]* {
    ; Calculate blocks needed (rounding up)
    blocks: int = (size + 127) / 128
    found: int = 0  ; how many consecutive free blocks found

    ; returns nth bit from the 32bit double word
    def block_taken(n: int) -> bool {
        if (n >= 16) return ((HEAP_TAKENl >> n) & 1) :: bool
        else return ((HEAP_TAKENh >> (n - 16)) & 1) :: bool
    }

    for (i: int = 0, i < 32, ++i) {
        if (block_taken(i)) {
            found = 0
        } else {
            found = found + 1
            if (found == blocks) {
                ; suitable block sequence found, return pointer to first block
                HEAP_LENGTHS[i - found] = found :: char
                return *HEAP + ((i - found) * 128) :: char[]*
            }
        }
    }

    ; No suitable block found
    error(*"malloc: Out of memory")
}

; Free implementation
def free(ptr: char[]*) -> void {
    ; Calculate the block index
    start: int = (ptr - *HEAP) :: int / 128
    blocks: int = HEAP_LENGTHS[start] :: int
    
    
    def free_block(n: int) -> void {
        if (n >= 16) HEAP_TAKENl = HEAP_TAKENl & ~(1 << n)
        else HEAP_TAKENh = HEAP_TAKENh & ~(1 << (n - 16))
    }

    for(i: int = 0, i < blocks, ++i) free_block(start + i)

    HEAP_LENGTHS[start + i] = 0c
}