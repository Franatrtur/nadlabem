; << Generated by NadLabem >>
; the open source brandejs-to-assembly compiler

cpu 8086
segment code
..start mov  bx, heap
        mov  ds, bx
        mov  es, bx
        mov  bx, stack
        mov  ss, bx
        mov  sp, dno
        mov  bp, sp

        lea  ax, [_str]          ;PrintLine(*"Čeština 😂👍") (41)
        push ax
        push ax
        call PrintLine
exit:
ok      hlt
error   hlt

PutChar:
        push bp                  ;def PutChar(character: char) -> void { (1)
        mov  bp, sp
        sub  sp, 0
        mov ah, 2                ;    $ mov ah, 2     ; Identifikace služby Vypsat jeden bajt na terminál (2)

        mov dl, byte[bp + 4]     ;    $ mov dl, byte[{character}]     ; Bajt, který se má na terminál vypsat (3)

        int 0x21                 ;    $ int 0x21      ; resp. int 33 poskytne službu (4)

rtn     mov  sp, bp
        pop  bp
        ret  2

GetChar:
        push bp                  ;def GetChar() -> char { (7)
        mov  bp, sp
        sub  sp, 0
        mov ah, 1                ;    $ mov ah, 1     ; Identifikace služby Načíst jeden bajt z terminálu (8)

        int 0x21                 ;    $ int 0x21      ; resp. int 33 poskytne službu (9)

        mov  al, al              ;    return $al (10)
        mov  ah, 0
        jmp  rtn1

rtn1    mov  sp, bp
        pop  bp
        ret  0

Print:
        push bp                  ;def Print(string: @char[]) -> void { (17)
        mov  bp, sp
        sub  sp, 3
        mov  ax, 0               ;    i: int = 0 (18)
        mov  word[bp - 2], ax

        mov  ax, 0               ;    byte: char = string[0] (19)
        mov  si, ax
        mov  bx, word[bp + 4]
        mov  ax, 0
        mov  al, byte[bx + si]
        mov  byte[bp - 3], al

while   nop                      ;    while(byte != 0c){ (20)
        mov  ax, 0
        push ax
        mov  ax, 0
        mov  al, byte[bp - 3]
        pop  bx
        cmp  ax, bx
        pushf
        pop  ax
        mov  cl, 6
        shr  ax, cl
        and  ax, 1
        xor  ax, 1
        jz   wout
        mov  ax, 0               ;        PutChar(byte) (21)
        mov  al, byte[bp - 3]
        push ax
        push ax
        call PutChar

        mov  ax, 1               ;        i = i + 1 (22)
        push ax
        mov  ax, word[bp - 2]
        pop  bx
        add  ax, bx
        mov  word[bp - 2], ax

        mov  ax, word[bp - 2]    ;        byte = string[i] (23)
        mov  si, ax
        mov  bx, word[bp + 4]
        mov  ax, 0
        mov  al, byte[bx + si]
        mov  byte[bp - 3], al

        jmp  while
wout    nop

rtn2    mov  sp, bp
        pop  bp
        ret  2

PrintDos:
        push bp                  ;def PrintDos(string: char[]*) -> void { (27)
        mov  bp, sp
        sub  sp, 0
        mov ah, 9                ;    $ mov ah, 9	                ; Identifikace služby Vypsat řetězec bajtů na terminál (28)

        mov dx, word[bp + 4]     ;    $ mov dx, word[{string}]    ; Offset začátku řetězce v segmentu dle DS (29)

        int 0x21                 ;    $ int 0x21                  ; resp. int 33 poskytne službu (30)

rtn3    mov  sp, bp
        pop  bp
        ret  2

PrintLine:
        push bp                  ;def PrintLine(string: @char[]) -> void { (33)
        mov  bp, sp
        sub  sp, 0
        mov  ax, word[bp + 4]    ;    Print(*string) (34)
        push ax
        call Print

        mov  ax, 10              ;    PutChar(10c)   ; 13 - CL (35)
        push ax
        push ax
        call PutChar

        mov  ax, 13              ;    PutChar(13c)   ; 10 - RF (36)
        push ax
        push ax
        call PutChar

rtn4    mov  sp, bp
        pop  bp
        ret  2

segment heap
stack   resw 1024
dno     db   ?

_str    db   196, 140, "e", 197, 161, "tina ", 240, 159, 152, 130, 240, 159, 145, 141, 0