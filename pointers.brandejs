int x = 2
bool mybool = true
array[char] myarr = [1, 50, 33, 'd']
string mystring = "https://prod.liveshare"

int pointer_to_x = *x   ;#0x3e4f
; same thing:
int* y = *x  ; y now references the same part of memory as x, as we defined it not by value, but by pointer
int* y = pointer_to_x

print_number(y) ; print 2
int* x = 2  ; we load 2 as the pointer, but should throw errow when strict 

y = y + 1     ; x is also now 3
print_number(x) ; prints 3

int* z = y+1; once again loads y + 1 as the address, but should throw errow when strict

array[int] arr = [1,2,3,x]
x = arr[1]  ; x=2
y = array   ; should throw error
y = mybool  ; should not throw error
x = arr[5]  ; no telling what part of memory we might load, but should throw errow when strict ?
x = arr[y]  


;two ways of doing the same thing:
int a = arr[i] ; we check that item type of arr is int when strict
int a = &(*arr + i * 2) ; we just give up on type checking here, warn when strict
; + 2 because int has two bytes in 8086 -> platfrom dependent


;arguments by val vs by ref(pointer):
int myfunc(int* ref, int val){
    val = ref   ; no outside change
    ref = val   ;modifies the original
    return *ref ; actually we can return a pointer as its an int
}
int* b = myfunc(x, a) ; x might change, a will not

; side note:  int* func(...){...} ; should throw error  always

;wild shit:
array[int] mixed_array = [*arr, *x, *y] ; array of ints - pointers to arr, to x, and to y
; should we somehow check the types there? probably not, too complicated

array[int]* arr_view = mixed_array[0] ; we view the pointer to arr as an array again (dereference)
z = & mixed_array[1]                     ; set z to x